/**
 * Copyright (C) 2015 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.strata.engine;

import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Stream;

import org.joda.beans.Bean;
import org.joda.beans.BeanDefinition;
import org.joda.beans.ImmutableBean;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaBean;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.google.common.collect.ImmutableList;
import com.opengamma.strata.collect.ArgChecker;
import com.opengamma.strata.collect.result.Result;

/**
 * The set of results calculated for a single target by the engine.
 * <p>
 * As the input to the engine is a list of targets, each {@code TradeResults} instance
 * holds a {@code targetIndex} field that indicates the position in the initial list
 * that a particular result is for.
 */
@BeanDefinition
public final class TradeResults implements ImmutableBean {

  /**
   * The position of the target as originally supplied to the engine.
   * This is used so that the target that a result is for can easily
   * be identified without need to be held in a separate identifier.
   */
  @PropertyDefinition(validate = "ArgChecker.notNegative")
  private final int tradeIndex;
  /**
   * The set of columns holding the results for each measure
   * that was initially requested. The order of these columns will
   * match the order in which the measures were requested.
   */
  @PropertyDefinition(validate = "notNull")
  private final ImmutableList<Result<?>> columns;

  //-------------------------------------------------------------------------
  /**
   * Create a new set of results.
   * <p>
   * The columns within the result must be in the same order as the input to the engine.
   *
   * @param targetIndex  the position of the target in the initial list
   *   of targets that calculations were requested for
   * @param columns  the result that has been calculated for each column,
   *   representing a measure
   * @return the results
   */
  public static TradeResults of(int targetIndex, List<Result<?>> columns) {
    return new TradeResults(targetIndex, columns);
  }

  //-------------------------------------------------------------------------
  /**
   * Gets the results for a column by index.
   * <p>
   * The result represents all the data for the combination of a single target and column.
   * The {@code targetIndex} refers to the list of targets that were the input to the engine.
   * 
   * @param columnIndex  the index of the column in the input list of columns
   * @return the results for the column, which may contain the results for scenarios
   */
  public Result<?> getColumn(int columnIndex) {
    return columns.get(columnIndex);
  }

  /**
   * Returns the number of columns, one for each measure.
   *
   * @return the number of columns
   */
  public int size() {
    return columns.size();
  }

  /**
   * Stream the individual column results, one for each measure.
   *
   * @return a stream of column results, one for each measure
   */
  public Stream<Result<?>> stream() {
    return columns.stream();
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code TradeResults}.
   * @return the meta-bean, not null
   */
  public static TradeResults.Meta meta() {
    return TradeResults.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(TradeResults.Meta.INSTANCE);
  }

  /**
   * Returns a builder used to create an instance of the bean.
   * @return the builder, not null
   */
  public static TradeResults.Builder builder() {
    return new TradeResults.Builder();
  }

  private TradeResults(
      int tradeIndex,
      List<Result<?>> columns) {
    ArgChecker.notNegative(tradeIndex, "tradeIndex");
    JodaBeanUtils.notNull(columns, "columns");
    this.tradeIndex = tradeIndex;
    this.columns = ImmutableList.copyOf(columns);
  }

  @Override
  public TradeResults.Meta metaBean() {
    return TradeResults.Meta.INSTANCE;
  }

  @Override
  public <R> Property<R> property(String propertyName) {
    return metaBean().<R>metaProperty(propertyName).createProperty(this);
  }

  @Override
  public Set<String> propertyNames() {
    return metaBean().metaPropertyMap().keySet();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the position of the target as originally supplied to the engine.
   * This is used so that the target that a result is for can easily
   * be identified without need to be held in a separate identifier.
   * @return the value of the property
   */
  public int getTradeIndex() {
    return tradeIndex;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the set of columns holding the results for each measure
   * that was initially requested. The order of these columns will
   * match the order in which the measures were requested.
   * @return the value of the property, not null
   */
  public ImmutableList<Result<?>> getColumns() {
    return columns;
  }

  //-----------------------------------------------------------------------
  /**
   * Returns a builder that allows this bean to be mutated.
   * @return the mutable builder, not null
   */
  public Builder toBuilder() {
    return new Builder(this);
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      TradeResults other = (TradeResults) obj;
      return (getTradeIndex() == other.getTradeIndex()) &&
          JodaBeanUtils.equal(getColumns(), other.getColumns());
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = getClass().hashCode();
    hash = hash * 31 + JodaBeanUtils.hashCode(getTradeIndex());
    hash = hash * 31 + JodaBeanUtils.hashCode(getColumns());
    return hash;
  }

  @Override
  public String toString() {
    StringBuilder buf = new StringBuilder(96);
    buf.append("TradeResults{");
    buf.append("tradeIndex").append('=').append(getTradeIndex()).append(',').append(' ');
    buf.append("columns").append('=').append(JodaBeanUtils.toString(getColumns()));
    buf.append('}');
    return buf.toString();
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code TradeResults}.
   */
  public static final class Meta extends DirectMetaBean {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code tradeIndex} property.
     */
    private final MetaProperty<Integer> tradeIndex = DirectMetaProperty.ofImmutable(
        this, "tradeIndex", TradeResults.class, Integer.TYPE);
    /**
     * The meta-property for the {@code columns} property.
     */
    @SuppressWarnings({"unchecked", "rawtypes" })
    private final MetaProperty<ImmutableList<Result<?>>> columns = DirectMetaProperty.ofImmutable(
        this, "columns", TradeResults.class, (Class) ImmutableList.class);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(
        this, null,
        "tradeIndex",
        "columns");

    /**
     * Restricted constructor.
     */
    private Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case 1855161806:  // tradeIndex
          return tradeIndex;
        case 949721053:  // columns
          return columns;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public TradeResults.Builder builder() {
      return new TradeResults.Builder();
    }

    @Override
    public Class<? extends TradeResults> beanType() {
      return TradeResults.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code tradeIndex} property.
     * @return the meta-property, not null
     */
    public MetaProperty<Integer> tradeIndex() {
      return tradeIndex;
    }

    /**
     * The meta-property for the {@code columns} property.
     * @return the meta-property, not null
     */
    public MetaProperty<ImmutableList<Result<?>>> columns() {
      return columns;
    }

    //-----------------------------------------------------------------------
    @Override
    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
      switch (propertyName.hashCode()) {
        case 1855161806:  // tradeIndex
          return ((TradeResults) bean).getTradeIndex();
        case 949721053:  // columns
          return ((TradeResults) bean).getColumns();
      }
      return super.propertyGet(bean, propertyName, quiet);
    }

    @Override
    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
      metaProperty(propertyName);
      if (quiet) {
        return;
      }
      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
    }

  }

  //-----------------------------------------------------------------------
  /**
   * The bean-builder for {@code TradeResults}.
   */
  public static final class Builder extends DirectFieldsBeanBuilder<TradeResults> {

    private int tradeIndex;
    private List<Result<?>> columns = ImmutableList.of();

    /**
     * Restricted constructor.
     */
    private Builder() {
    }

    /**
     * Restricted copy constructor.
     * @param beanToCopy  the bean to copy from, not null
     */
    private Builder(TradeResults beanToCopy) {
      this.tradeIndex = beanToCopy.getTradeIndex();
      this.columns = beanToCopy.getColumns();
    }

    //-----------------------------------------------------------------------
    @Override
    public Object get(String propertyName) {
      switch (propertyName.hashCode()) {
        case 1855161806:  // tradeIndex
          return tradeIndex;
        case 949721053:  // columns
          return columns;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
    }

    @SuppressWarnings("unchecked")
    @Override
    public Builder set(String propertyName, Object newValue) {
      switch (propertyName.hashCode()) {
        case 1855161806:  // tradeIndex
          this.tradeIndex = (Integer) newValue;
          break;
        case 949721053:  // columns
          this.columns = (List<Result<?>>) newValue;
          break;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
      return this;
    }

    @Override
    public Builder set(MetaProperty<?> property, Object value) {
      super.set(property, value);
      return this;
    }

    @Override
    public Builder setString(String propertyName, String value) {
      setString(meta().metaProperty(propertyName), value);
      return this;
    }

    @Override
    public Builder setString(MetaProperty<?> property, String value) {
      super.setString(property, value);
      return this;
    }

    @Override
    public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
      super.setAll(propertyValueMap);
      return this;
    }

    @Override
    public TradeResults build() {
      return new TradeResults(
          tradeIndex,
          columns);
    }

    //-----------------------------------------------------------------------
    /**
     * Sets the {@code tradeIndex} property in the builder.
     * @param tradeIndex  the new value
     * @return this, for chaining, not null
     */
    public Builder tradeIndex(int tradeIndex) {
      ArgChecker.notNegative(tradeIndex, "tradeIndex");
      this.tradeIndex = tradeIndex;
      return this;
    }

    /**
     * Sets the {@code columns} property in the builder.
     * @param columns  the new value, not null
     * @return this, for chaining, not null
     */
    public Builder columns(List<Result<?>> columns) {
      JodaBeanUtils.notNull(columns, "columns");
      this.columns = columns;
      return this;
    }

    //-----------------------------------------------------------------------
    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder(96);
      buf.append("TradeResults.Builder{");
      buf.append("tradeIndex").append('=').append(JodaBeanUtils.toString(tradeIndex)).append(',').append(' ');
      buf.append("columns").append('=').append(JodaBeanUtils.toString(columns));
      buf.append('}');
      return buf.toString();
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}
